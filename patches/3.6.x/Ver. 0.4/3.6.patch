#
# Patch: Version 0.4 [Recommend] mozbuildtools 1.2
#
# For: Mozilla Firefox 3.6 ( Gecko 1.9.2 )
#
--- a/js/src/configure.in
+++ b/js/src/configure.in
@@ -179,5 +179,5 @@
     if test -z "$CXX"; then CXX=cl; fi
     if test -z "$CPP"; then CPP="cl -E -nologo"; fi
-    if test -z "$CXXCPP"; then CXXCPP="cl -TP -E -nologo"; ac_cv_prog_CXXCPP="$CXXCPP"; fi
+    if test -z "$CXXCPP"; then CXXCPP="cl -TP -E -nologo"; fi ; ac_cv_prog_CXXCPP="$CXXCPP"
     if test -z "$LD"; then LD=link; fi
     if test -z "$AS"; then AS=ml; fi
@@ -520,6 +520,7 @@
         unset _MSVC_VER_FILTER
 
     else
+        _WIN32_MINGW=1
         # Check w32api version
         _W32API_MAJOR_VERSION=`echo $W32API_VERSION | $AWK -F\. '{ print $1 }'`
         _W32API_MINOR_VERSION=`echo $W32API_VERSION | $AWK -F\. '{ print $2 }'`
@@ -604,6 +605,9 @@
         AC_DEFINE(JS_STDDEF_H_HAS_INTPTR_T)
         ;;
     esac
+elif test -n "$_WIN32_MINGW" ; then
+    AC_DEFINE(HAVE_SYSTEMTIMETOFILETIME)
+    AC_DEFINE(HAVE_GETSYSTEMTIMEASFILETIME)
 fi
 
 fi # COMPILE_ENVIRONMENT
@@ -5287,5 +5291,5 @@
 
 # Produce the js-config script at configure time; see the comments for
 # 'js-config' in Makefile.in.
-AC_MSG_RESULT(invoking make to create js-config script)
-$MAKE js-config
+#AC_MSG_RESULT(invoking make to create js-config script)
+#$MAKE js-config
--- a/nsprpub/configure.in
+++ b/nsprpub/configure.in
@@ -714,6 +714,10 @@
     OS_ARCH='CYGWIN_NT-4.0'
     OS_TARGET=WIN95
     ;;
+MINGW32_NT*)
+    OS_ARCH='WINNT'
+    OS_TARGET=WIN95
+    ;;
 OS_2)
     OS_ARCH=OS2
     OS_TARGET=OS2
--- a/Makefile.in
+++ b/Makefile.in
@@ -95,6 +95,10 @@
 	$(RM) -rf $(DIST)/public
 	$(RM) -rf $(DIST)/bin/components
 	$(RM) -rf _tests
+ifeq ($(OS_ARCH),WINNT)
+	test ! -d $(DIST)/bin && mkdir -p $(DIST)/bin ; echo
+	for files in `find "${MOZ_TOOLS}/bin" -name '*.dll'` ; do cp "$$files" "$(DIST)/bin" ; done ;
+endif
 
 # Build pseudo-external modules first when export is explicitly called
 export::
--- a/config/config.mk
+++ b/config/config.mk
@@ -392,8 +392,10 @@
 OS_CXXFLAGS += $(PROFILE_GEN_CFLAGS)
 OS_LDFLAGS += $(PROFILE_GEN_LDFLAGS)
 ifeq (WINNT,$(OS_ARCH))
+ifndef GNU_CC
 AR_FLAGS += -LTCG
 endif
+endif
 endif # INTERNAL_TOOLS
 endif # MOZ_PROFILE_GENERATE
 
@@ -403,8 +405,10 @@
 OS_CXXFLAGS += $(PROFILE_USE_CFLAGS)
 OS_LDFLAGS += $(PROFILE_USE_LDFLAGS)
 ifeq (WINNT,$(OS_ARCH))
+ifndef GNU_CC
 AR_FLAGS += -LTCG
 endif
+endif
 endif # INTERNAL_TOOLS
 endif # MOZ_PROFILE_USE
 endif # NO_PROFILE_GUIDED_OPTIMIZE
--- a/configure.in
+++ b/configure.in
@@ -189,7 +189,7 @@
     if test -z "$CC"; then CC=cl; fi
     if test -z "$CXX"; then CXX=cl; fi
     if test -z "$CPP"; then CPP="cl -E -nologo"; fi
-    if test -z "$CXXCPP"; then CXXCPP="cl -TP -E -nologo"; ac_cv_prog_CXXCPP="$CXXCPP"; fi
+    if test -z "$CXXCPP"; then CXXCPP="cl -TP -E -nologo"; fi; ac_cv_prog_CXXCPP="$CXXCPP"
     if test -z "$LD"; then LD=link; fi
     if test -z "$AS"; then AS=ml; fi
     if test -z "$MIDL"; then MIDL=midl; fi
@@ -2122,7 +2122,7 @@
         DYNAMIC_XPCOM_LIBS='-L$(LIBXUL_DIST)/lib -lxpcom -lxpcom_core'
         XPCOM_FROZEN_LDOPTS='-L$(LIBXUL_DIST)/lib -lxpcom'
         DLL_PREFIX=
-        IMPORT_LIB_SUFFIX=dll.a
+        IMPORT_LIB_SUFFIX=a
     else
         TARGET_COMPILER_ABI=msvc
         HOST_CC='$(CC)'
@@ -2250,16 +2250,29 @@
     else
         _GLIB_PREFIX_DIR=$MOZ_TOOLS_DIR
     fi
-    if test ! -f "${_GLIB_PREFIX_DIR}/include/glib.h"; then
-        AC_MSG_ERROR([Cannot find $_GLIB_PREFIX_DIR/include/glib.h .])
+
+    if test -n "`pkg-config --cflags glib-2.0 2> /dev/null`"; then
+        GLIB_CFLAGS="`pkg-config --cflags glib-2.0 2> /dev/null`"
+    elif test -f "${_GLIB_PREFIX_DIR}/include/glib.h"; then
+        GLIB_CFLAGS="-I${_GLIB_PREFIX_DIR}/include"
+    elif test -f "${_GLIB_PREFIX_DIR}/include/glib-2.0/glib.h"; then
+        GLIB_CFLAGS="-I${_GLIB_PREFIX_DIR}/include/glib-2.0 -I${_GLIB_PREFIX_DIR}/lib/glib-2.0/include"
+    else
+        AC_MSG_ERROR([Glib isn't installed or doesn't work.  Please check the environment variable \$MOZ_TOOLS .])
     fi
-    GLIB_CFLAGS="-I${_GLIB_PREFIX_DIR}/include"
-    if test -f "${_GLIB_PREFIX_DIR}/lib/glib-1.2_s.lib"; then
+	
+	if test -n "`pkg-config --libs glib-2.0 2> /dev/null`"; then
+        GLIB_LIBS="`pkg-config --libs glib-2.0 2> /dev/null`"
+    elif test -f "${_GLIB_PREFIX_DIR}/lib/glib-1.2_s.lib"; then
         GLIB_LIBS="${_GLIB_PREFIX_DIR}/lib/glib-1.2_s.lib"
     elif test -f "${_GLIB_PREFIX_DIR}/lib/glib-1.2.lib"; then
         GLIB_LIBS="${_GLIB_PREFIX_DIR}/lib/glib-1.2.lib"
+    elif test -f "${_GLIB_PREFIX_DIR}/lib/glib-2.0.lib"; then
+        GLIB_LIBS="${_GLIB_PREFIX_DIR}/lib/glib-2.0.lib"
+    elif test -f "${_GLIB_PREFIX_DIR}/lib/libglib-2.0.a"; then
+        GLIB_LIBS="${_GLIB_PREFIX_DIR}/lib/libglib-2.0.a"
     else
-        AC_MSG_ERROR([Cannot find $_GLIB_PREFIX_DIR/lib/glib-1.2.lib or $_GLIB_PREFIX_DIR/lib/glib-1.2_s.lib])
+        AC_MSG_ERROR([Glib isn't installed or doesn't work.  Please check the environment variable \$MOZ_TOOLS .])
     fi
 
     if test -n "$LIBIDL_PREFIX"; then
@@ -2275,17 +2288,30 @@
     else
         _LIBIDL_PREFIX_DIR=$MOZ_TOOLS_DIR
     fi        
-    if test ! -f "${_LIBIDL_PREFIX_DIR}/include/libIDL/IDL.h"; then
-        AC_MSG_ERROR([Cannot find $_LIBIDL_PREFIX_DIR/include/libIDL/IDL.h .])
+	
+    if test -n "`pkg-config --cflags libIDL-2.0 2> /dev/null`"; then
+        LIBIDL_CFLAGS="`pkg-config --cflags libIDL-2.0 2> /dev/null`"
+    elif test -f "${_LIBIDL_PREFIX_DIR}/include/libIDL-2.0/libIDL/IDL.h"; then
+        LIBIDL_CFLAGS="-I${_LIBIDL_PREFIX_DIR}/include/libIDL-2.0 ${GLIB_CFLAGS}"
+    elif test -f "${_LIBIDL_PREFIX_DIR}/include/libIDL/IDL.h"; then
+        LIBIDL_CFLAGS="-I${_LIBIDL_PREFIX_DIR}/include ${GLIB_CFLAGS}"
+    else
+        AC_MSG_ERROR([libIDL isn't installed or doesn't work.  Please check the environment variable \$MOZ_TOOLS .])
     fi
-    LIBIDL_CFLAGS="-I${_LIBIDL_PREFIX_DIR}/include ${GLIB_CFLAGS}"
-    if test -f "${_LIBIDL_PREFIX_DIR}/lib/libidl-0.6_s.lib"; then
+    
+    if test -n "`pkg-config --libs libIDL-2.0 2> /dev/null`"; then
+        LIBIDL_LIBS="`pkg-config --libs libIDL-2.0 2> /dev/null`"
+    elif test -f "${_LIBIDL_PREFIX_DIR}/lib/libIDL-2.lib"; then
+        LIBIDL_LIBS="${_LIBIDL_PREFIX_DIR}/lib/libIDL-2.lib"
+    elif test -f "${_LIBIDL_PREFIX_DIR}/lib/libIDL-2.a"; then
+        LIBIDL_LIBS="${_LIBIDL_PREFIX_DIR}/lib/libIDL-2.a"
+    elif test -f "${_LIBIDL_PREFIX_DIR}/lib/libidl-0.6_s.lib"; then
         LIBIDL_LIBS="${_LIBIDL_PREFIX_DIR}/lib/libidl-0.6_s.lib"
         STATIC_LIBIDL=1
     elif test -f "${_LIBIDL_PREFIX_DIR}/lib/libidl-0.6.lib"; then
         LIBIDL_LIBS="${_LIBIDL_PREFIX_DIR}/lib/libidl-0.6.lib"
     else
-        AC_MSG_ERROR([Cannot find $_LIBIDL_PREFIX_DIR/lib/libidl-0.6.lib or $_LIBIDL_PREFIX_DIR/lib/libidl-0.6_s.lib])
+        AC_MSG_ERROR([libIDL isn't installed or doesn't work.  Please check the environment variable \$MOZ_TOOLS .])
     fi
     LIBIDL_LIBS="${LIBIDL_LIBS} ${GLIB_LIBS}"
     ;;
@@ -4515,6 +4541,7 @@
 MOZ_NO_INSPECTOR_APIS=
 MOZ_NO_XPCOM_OBSOLETE=
 MOZ_NO_FAST_LOAD=
+NS_ENABLE_TSF=1
 MOZ_OGG=1
 MOZ_SYDNEYAUDIO=
 MOZ_WAVE=1
@@ -5499,6 +5526,25 @@
     AC_DEFINE(MOZ_NO_FAST_LOAD)
 fi
 
+dnl
+dnl Text Services Framework support
+dnl
+if test "$GNU_CC" ; then
+    NS_ENABLE_TSF=
+fi
+if test "$WINCE" ; then
+    NS_ENABLE_TSF=
+fi
+
+MOZ_ARG_DISABLE_BOOL(tsf,
+[  --disable-tsf       Disable Text Services Framework support],
+    NS_ENABLE_TSF=,
+    NS_ENABLE_TSF=1)
+AC_SUBST(NS_ENABLE_TSF)
+if test "$NS_ENABLE_TSF"; then
+    AC_DEFINE(NS_ENABLE_TSF)
+fi
+
 dnl ========================================================
 dnl = Disable Ogg Codecs
 dnl ========================================================
@@ -7984,6 +8030,7 @@
 AC_SUBST(BIN_FLAGS)
 AC_SUBST(NS_USE_NATIVE)
 AC_SUBST(MOZ_WIDGET_TOOLKIT)
+AC_SUBST(NS_ENABLE_TSF)
 AC_SUBST(MOZ_GFX_TOOLKIT)
 AC_SUBST(MOZ_UPDATE_XTERM)
 AC_SUBST(MINIMO)
--- a/security/manager/Makefile.in
+++ b/security/manager/Makefile.in
@@ -180,6 +180,8 @@
 DEFAULT_GMAKE_FLAGS += MOZILLA_CLIENT=1
 DEFAULT_GMAKE_FLAGS += NO_MDUPDATE=1
 DEFAULT_GMAKE_FLAGS += NSS_ENABLE_ECC=1
+# Pass theIMPORT_LIB_SUFFIX into the sub makefiles
+DEFAULT_GMAKE_FLAGS += IMPORT_LIB_SUFFIX=.$(IMPORT_LIB_SUFFIX)
 ifdef NSS_DISABLE_DBM 
 DEFAULT_GMAKE_FLAGS += NSS_DISABLE_DBM=1
 endif
--- a/js/src/jstracer.cpp
+++ b/js/src/jstracer.cpp
@@ -50,6 +50,15 @@
 #define alloca _alloca
 #endif
 #endif
+
+//MinGW
+#ifdef __GNUC__
+#ifndef HAVE_ALLOCA_H
+#include <malloc.h>
+#define alloca _alloca
+#endif
+#endif
+
 #ifdef SOLARIS
 #include <alloca.h>
 #endif
--- a/js/src/nanojit/Nativei386.cpp
+++ b/js/src/nanojit/Nativei386.cpp
@@ -257,7 +257,7 @@
     {
         Register r;
         RegAlloc &regs = _allocator;
-    #ifdef WIN32
+	 #if (defined WIN32) && (!defined __MINGW32__)
         _asm
         {
             mov ecx, regs
--- a/modules/libpr0n/decoders/png/nsPNGDecoder.cpp
+++ b/modules/libpr0n/decoders/png/nsPNGDecoder.cpp
@@ -57,6 +57,8 @@
 #include "png.h"
 
 #include "gfxPlatform.h"
+
+#include <limits.h>
 
 static void PNGAPI info_callback(png_structp png_ptr, png_infop info_ptr);
 static void PNGAPI row_callback(png_structp png_ptr, png_bytep new_row,
--- a/widget/src/windows/nsWindow.h
+++ b/widget/src/windows/nsWindow.h
@@ -76,9 +76,11 @@
 #endif
 
 // Text Services Framework support
-#if !defined(WINCE)
+//#if ! ( defined WINCE  ||  defined __MINGW32__ )
+//#define NS_ENABLE_TSF
+//#endif // !defined(WINCE)
+
-#define NS_ENABLE_TSF
+//#define NS_ENABLE_TSF
-#endif // !defined(WINCE)
 
 /**
  * Forward class definitions
--- a/media/liboggz/include/oggz/config_win32.h
+++ b/media/liboggz/include/oggz/config_win32.h
@@ -1,6 +1,9 @@
 /* config.h.  Generated by configure.  */
 /* config.h.in.  Generated from configure.ac by autoheader.  */
 
+#if ! ( defined LIBOGGZ_CONFIG_WIN32_H )
+#define LIBOGGZ_CONFIG_WIN32_H
+
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #undef HAVE_DLFCN_H
 
@@ -135,4 +138,6 @@
 /* Define for MSVC as <stdint.h> is unavailable there */
 typedef unsigned char uint8_t;
 
-#define inline __inline // MSVC
\ No newline at end of file
+#define inline __inline // MSVC
+ 
+#endif
--- a/gfx/thebes/src/gfxWindowsFonts.cpp
+++ a/gfx/thebes/src/gfxWindowsFonts.cpp
@@ -1183,6 +1183,6 @@
         // delete it immediately it goes out of scope, not call
         // gfxFont::Release which deals with shared, cached font instances.
-        nsAutoPtr<gfxWindowsFont> tempFont =
-            new gfxWindowsFont(GetFontEntry(), GetStyle(), CAIRO_ANTIALIAS_NONE);
+        nsAutoPtr<gfxWindowsFont> tempFont 
+           (new gfxWindowsFont(GetFontEntry(), GetStyle(), CAIRO_ANTIALIAS_NONE));
         if (tempFont) {
             return tempFont->Measure(aTextRun, aStart, aEnd,
--- a/widget/src/windows/Makefile.in
+++ a/widget/src/windows/Makefile.in
@@ -126,4 +126,8 @@
 	nsBidiKeyboard.cpp   \
-	nsTextStore.cpp \
 	$(NULL)
+ifdef NS_ENABLE_TSF
+CPPSRCS += \
+	nsTextStore.cpp \
+	$(NULL)
+endif
 endif
--- a/security/nss/lib/freebl/config.mk
+++ b/security/nss/lib/freebl/config.mk
@@ -85,7 +85,11 @
 RESNAME = freebl.rc
 
 ifndef WINCE
+ifdef NS_USE_GCC
+OS_LIBS += -lshell32
+else
 OS_LIBS += shell32.lib
+endif
 endif
 
 ifdef NS_USE_GCC
--- a/widget/src/windows/nsIMM32Handler.cpp
+++ b/widget/src/windows/nsIMM32Handler.cpp
@@ -23,26 +23,26 @@
  */
-
+#undef UNICODE
 typedef BOOL (*sh_FileFcn)(
-        wchar_t *pathName,
+        char *pathName,
         WIN32_FIND_DATA *fileData,
         void *arg);
 
-static int shellCp (wchar_t **pArgv); 
-static int shellNsinstall (wchar_t **pArgv);
-static int shellMkdir (wchar_t **pArgv); 
-static BOOL sh_EnumerateFiles(const wchar_t *pattern, const wchar_t *where,
+static int shellCp (char **pArgv); 
+static int shellNsinstall (char **pArgv);
+static int shellMkdir (char **pArgv); 
+static BOOL sh_EnumerateFiles(const char *pattern, const char *where,
         sh_FileFcn fileFcn, void *arg, int *nFiles);
 static const char *sh_GetLastErrorMessage(void);
-static BOOL sh_DoCopy(wchar_t *srcFileName, DWORD srcFileAttributes,
-        wchar_t *dstFileName, DWORD dstFileAttributes,
+static BOOL sh_DoCopy(char *srcFileName, DWORD srcFileAttributes,
+        char *dstFileName, DWORD dstFileAttributes,
         int force, int recursive);
 
-#define LONGPATH_PREFIX L"\\\\?\\"
+#define LONGPATH_PREFIX "\\\\?\\"
 #define ARRAY_LEN(a) (sizeof(a) / sizeof(a[0]))
 #define STR_LEN(a) (ARRAY_LEN(a) - 1)
 
 /* changes all forward slashes in token to backslashes */
-void changeForwardSlashesToBackSlashes ( wchar_t *arg )
+void changeForwardSlashesToBackSlashes ( char *arg )
 {
     if ( arg == NULL )
         return;
@@ -54,18 +54,18 @@
     }
 }
 
-int wmain(int argc, wchar_t *argv[ ])
+int main(int argc, char *argv[ ])
 {
     return shellNsinstall ( argv + 1 );
 }
 
 static int
-shellNsinstall (wchar_t **pArgv)
+shellNsinstall (char **pArgv)
 {
     int retVal = 0;     /* exit status */
     int dirOnly = 0;    /* 1 if and only if -D is specified */
-    wchar_t **pSrc;
-    wchar_t **pDst;
+    char **pSrc;
+    char **pDst;
 
     /*
      * Process the command-line options.  We ignore the
@@ -74,7 +74,7 @@
      * argument too.
      */
     while ( *pArgv && **pArgv == '-' ) {
-        wchar_t c = (*pArgv)[1];  /* The char after '-' */
+        char c = (*pArgv)[1];  /* The char after '-' */
 
         if ( c == 'D' ) {
             dirOnly = 1;
@@ -117,14 +117,14 @@
 }
 
 static int
-shellMkdir (wchar_t **pArgv) 
+shellMkdir (char **pArgv) 
 {
     int retVal = 0; /* assume valid return */
-    wchar_t *arg;
-    wchar_t *pArg;
-    wchar_t path[_MAX_PATH];
-    wchar_t tmpPath[_MAX_PATH];
-    wchar_t *pTmpPath = tmpPath;
+    char *arg;
+    char *pArg;
+    char path[_MAX_PATH];
+    char tmpPath[_MAX_PATH];
+    char *pTmpPath = tmpPath;
 
     /* All the options are simply ignored in this implementation */
     while ( *pArgv && **pArgv == '-' ) {
@@ -149,12 +149,12 @@
             *pTmpPath = '\0';
 
             /* check if directory already exists */
-            _wgetcwd ( path, _MAX_PATH );
-            if ( _wchdir ( tmpPath ) != -1 ) {
-                _wchdir ( path );
+            _getcwd ( path, _MAX_PATH );
+            if ( _chdir ( tmpPath ) != -1 ) {
+                _chdir ( path );
             } else {
-                if ( _wmkdir ( tmpPath ) == -1 ) {
-                    printf ( "%ls: ", tmpPath );
+                if ( _mkdir ( tmpPath ) == -1 ) {
+                    printf ( "%s: ", tmpPath );
                     perror ( "Could not create the directory" );
                     retVal = 3;
                     break;
@@ -195,7 +195,7 @@
  */
 
 struct sh_FileData {
-    wchar_t pathName[_MAX_PATH];
+    char pathName[_MAX_PATH];
     DWORD dwFileAttributes;
 };
 
@@ -213,19 +213,19 @@
  */
 
 static BOOL
-sh_RecordFileData(wchar_t *pathName, WIN32_FIND_DATA *findData, void *arg)
+sh_RecordFileData(char *pathName, WIN32_FIND_DATA *findData, void *arg)
 {
     struct sh_FileData *fData = (struct sh_FileData *) arg;
 
-    wcscpy(fData->pathName, pathName);
+    strcpy(fData->pathName, pathName);
     fData->dwFileAttributes = findData->dwFileAttributes;
     return TRUE;
 }
 
 static BOOL
-sh_DoCopy(wchar_t *srcFileName,
+sh_DoCopy(char *srcFileName,
           DWORD srcFileAttributes,
-          wchar_t *dstFileName,
+          char *dstFileName,
           DWORD dstFileAttributes,
           int force,
           int recursive
@@ -239,28 +239,28 @@
     }
 
     if (srcFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
-        fprintf(stderr, "nsinstall: %ls is a directory\n",
+        fprintf(stderr, "nsinstall: %s is a directory\n",
                 srcFileName);
         return FALSE;
     } else {
         DWORD r;
-        wchar_t longSrc[1004] = LONGPATH_PREFIX;
-        wchar_t longDst[1004] = LONGPATH_PREFIX;
+        char longSrc[1004] = LONGPATH_PREFIX;
+        char longDst[1004] = LONGPATH_PREFIX;
         r = GetFullPathName(srcFileName, 1000, longSrc + STR_LEN(LONGPATH_PREFIX), NULL);
         if (!r) {
-            fprintf(stderr, "nsinstall: couldn't get full path of %ls: %s\n",
+            fprintf(stderr, "nsinstall: couldn't get full path of %s: %s\n",
                     srcFileName, sh_GetLastErrorMessage());
             return FALSE;
         }
         r = GetFullPathName(dstFileName, 1000, longDst + ARRAY_LEN(LONGPATH_PREFIX) - 1, NULL);
         if (!r) {
-            fprintf(stderr, "nsinstall: couldn't get full path of %ls: %s\n",
+            fprintf(stderr, "nsinstall: couldn't get full path of %s: %s\n",
                     dstFileName, sh_GetLastErrorMessage());
             return FALSE;
         }
 
         if (!CopyFile(longSrc, longDst, FALSE)) {
-            fprintf(stderr, "nsinstall: cannot copy %ls to %ls: %s\n",
+            fprintf(stderr, "nsinstall: cannot copy %s to %s: %s\n",
                     srcFileName, dstFileName, sh_GetLastErrorMessage());
             return FALSE;
         }
@@ -282,9 +282,9 @@
     int recursive;            /* -r or -R option, recursively copy
                                * directories. Note: this field is not used
                                * by nsinstall and should always be 0. */
-    wchar_t *dstFileName;        /* a buffer for constructing the destination
+    char *dstFileName;        /* a buffer for constructing the destination
                                * file name */
-    wchar_t *dstFileNameMarker;  /* points to where in the dstFileName buffer
+    char *dstFileNameMarker;  /* points to where in the dstFileName buffer
                                * we should write the file component of the
                                * destination file */
 };
@@ -302,23 +302,23 @@
  */
 
 static BOOL
-sh_CpFileCmd(wchar_t *pathName, WIN32_FIND_DATA *findData, void *cpArg)
+sh_CpFileCmd(char *pathName, WIN32_FIND_DATA *findData, void *cpArg)
 {
     BOOL retVal = TRUE;
     struct sh_CpCmdArg *arg = (struct sh_CpCmdArg *) cpArg;
 
-    wcscpy(arg->dstFileNameMarker, findData->cFileName);
+    strcpy(arg->dstFileNameMarker, findData->cFileName);
     return sh_DoCopy(pathName, findData->dwFileAttributes,
             arg->dstFileName, GetFileAttributes(arg->dstFileName),
             arg->force, arg->recursive);
 }
 
 static int
-shellCp (wchar_t **pArgv) 
+shellCp (char **pArgv) 
 {
     int retVal = 0;
-    wchar_t **pSrc;
-    wchar_t **pDst;
+    char **pSrc;
+    char **pDst;
     struct sh_CpCmdArg arg;
     struct sh_FileData dstData;
     int dstIsDir = 0;
@@ -330,7 +330,7 @@
     arg.dstFileNameMarker = 0;
 
     while (*pArgv && **pArgv == '-') {
-        wchar_t *p = *pArgv;
+        char *p = *pArgv;
 
         while (*(++p)) {
             if (*p == 'f') {
@@ -376,7 +376,7 @@
             dstIsDir = 1;
         }
     } else if (n > 1) {
-        fprintf(stderr, "nsinstall: %ls: ambiguous destination file "
+        fprintf(stderr, "nsinstall: %s: ambiguous destination file "
                 "or directory\n", *pDst);
         return 3;
     } else {
@@ -386,11 +386,11 @@
          * name must be fully specified.
          */
 
-        wchar_t *p;
+        char *p;
 
         for (p = *pDst; *p; p++) {
             if (*p == '*' || *p == '?') {
-                fprintf(stderr, "nsinstall: %ls: No such file or directory\n",
+                fprintf(stderr, "nsinstall: %s: No such file or directory\n",
                         *pDst);
                 return 3;
             }
@@ -404,7 +404,7 @@
         if (p > *pDst && p[-1] == '\\' && p != *pDst + 1 && p[-2] != ':') {
             p[-1] = '\0';
         }
-        wcscpy(dstData.pathName, *pDst);
+        strcpy(dstData.pathName, *pDst);
         dstData.dwFileAttributes = 0xFFFFFFFF;
     }
 
@@ -420,7 +420,7 @@
     }
 
     if (dstIsDir) {
-        arg.dstFileNameMarker = arg.dstFileName + wcslen(arg.dstFileName);
+        arg.dstFileNameMarker = arg.dstFileName + strlen(arg.dstFileName);
 
         /*
          * Now arg.dstFileNameMarker is pointing to the null byte at the
@@ -441,7 +441,7 @@
         changeForwardSlashesToBackSlashes(*pSrc);
         sh_EnumerateFiles(*pSrc, *pSrc, sh_RecordFileData, &srcData, &n);
         if (n == 0) {
-            fprintf(stderr, "nsinstall: %ls: No such file or directory\n",
+            fprintf(stderr, "nsinstall: %s: No such file or directory\n",
                     *pSrc);
             retVal = 3;
         } else if (n > 1) {
@@ -468,7 +468,7 @@
             retVal = 3;
         } else {
             if (n == 0) {
-                fprintf(stderr, "nsinstall: %ls: No such file or directory\n",
+                fprintf(stderr, "nsinstall: %s: No such file or directory\n",
                         *pSrc);
                 retVal = 3;
             }
@@ -499,8 +499,8 @@
  */
 
 static BOOL sh_EnumerateFiles(
-        const wchar_t *pattern,
-        const wchar_t *where,
+        const char *pattern,
+        const char *where,
         sh_FileFcn fileFcn,
         void *arg,
         int *nFiles
@@ -508,11 +508,11 @@
 {
     WIN32_FIND_DATA fileData;
     HANDLE hSearch;
-    const wchar_t *src;
-    wchar_t *dst;
-    wchar_t fileName[_MAX_PATH];
-    wchar_t *fileNameMarker = fileName;
-    wchar_t *oldFileNameMarker;
+    const char *src;
+    char *dst;
+    char fileName[_MAX_PATH];
+    char *fileNameMarker = fileName;
+    char *oldFileNameMarker;
     BOOL hasWildcard = FALSE;
     BOOL retVal = TRUE;
     BOOL patternEndsInDotStar = FALSE;
@@ -530,10 +530,10 @@
      * function.  We require that a matched filename have at least
      * the number of dots in the pattern.
      */
-    len = wcslen(pattern);
+    len = strlen(pattern);
     if (len >= 2) {
         /* Start from the end of pattern and go backward */
-        const wchar_t *p = &pattern[len - 1];
+        const char *p = &pattern[len - 1];
 
         /* We can have zero or more *'s */
         while (p >= pattern && *p == '*') {
@@ -613,8 +613,8 @@
          * See if it is the root directory, \, or X:\.
          */
 
-        assert(!wcscmp(fileName, pattern));
-        assert(wcslen(fileName) >= 1);
+        assert(!strcmp(fileName, pattern));
+        assert(strlen(fileName) >= 1);
         if (dst[-1] == '\\' && (dst == fileName + 1 || dst[-2] == ':')) {
             fileData.cFileName[0] = '\0';
         } else {
@@ -627,7 +627,7 @@
                 dst[-1] = '\0';
                 fileNameMarker = oldFileNameMarker;
             } 
-            wcscpy(fileData.cFileName, fileNameMarker);
+            strcpy(fileData.cFileName, fileNameMarker);
         }
         fileData.dwFileAttributes = GetFileAttributes(fileName);
         if (fileData.dwFileAttributes == 0xFFFFFFFF) {
@@ -643,8 +643,8 @@
     }
 
     do {
-        if (!wcscmp(fileData.cFileName, L".")
-                || !wcscmp(fileData.cFileName, L"..")) {
+        if (!strcmp(fileData.cFileName, ".")
+                || !strcmp(fileData.cFileName, "..")) {
             /* 
              * Skip over . and ..
              */
@@ -654,7 +654,7 @@
 
         if (patternEndsInDotStar) {
             int nDots = 0;
-            wchar_t *p = fileData.cFileName;
+            char *p = fileData.cFileName;
             while (*p) {
                 if (*p == '.') {
                     nDots++;
@@ -680,7 +680,7 @@
             }
         }
 
-        wcscpy(fileNameMarker, fileData.cFileName);
+        strcpy(fileNameMarker, fileData.cFileName);
         if (*src && *(src + 1)) {
             /*
              * More to go.  Recurse.
@@ -689,13 +689,13 @@
             int n;
 
             assert(*src == '\\');
-            where = fileName + wcslen(fileName);
-            wcscat(fileName, src);
+            where = fileName + strlen(fileName);
+            strcat(fileName, src);
             sh_EnumerateFiles(fileName, where, fileFcn, arg, &n);
             *nFiles += n;
         } else {
-            assert(wcschr(fileName, '*') == NULL);
-            assert(wcschr(fileName, '?') == NULL);
+            assert(strchr(fileName, '*') == NULL);
+            assert(strchr(fileName, '?') == NULL);
             (*nFiles)++;
             if ((*fileFcn)(fileName, &fileData, arg) == FALSE) {
                 retVal = FALSE;
--- a/js/src/config/nsinstall_win.c
+++ b/js/src/config/nsinstall_win.c
@@ -23,26 +23,26 @@
  */
-
+#undef UNICODE
 typedef BOOL (*sh_FileFcn)(
-        wchar_t *pathName,
+        char *pathName,
         WIN32_FIND_DATA *fileData,
         void *arg);
 
-static int shellCp (wchar_t **pArgv); 
-static int shellNsinstall (wchar_t **pArgv);
-static int shellMkdir (wchar_t **pArgv); 
-static BOOL sh_EnumerateFiles(const wchar_t *pattern, const wchar_t *where,
+static int shellCp (char **pArgv); 
+static int shellNsinstall (char **pArgv);
+static int shellMkdir (char **pArgv); 
+static BOOL sh_EnumerateFiles(const char *pattern, const char *where,
         sh_FileFcn fileFcn, void *arg, int *nFiles);
 static const char *sh_GetLastErrorMessage(void);
-static BOOL sh_DoCopy(wchar_t *srcFileName, DWORD srcFileAttributes,
-        wchar_t *dstFileName, DWORD dstFileAttributes,
+static BOOL sh_DoCopy(char *srcFileName, DWORD srcFileAttributes,
+        char *dstFileName, DWORD dstFileAttributes,
         int force, int recursive);
 
-#define LONGPATH_PREFIX L"\\\\?\\"
+#define LONGPATH_PREFIX "\\\\?\\"
 #define ARRAY_LEN(a) (sizeof(a) / sizeof(a[0]))
 #define STR_LEN(a) (ARRAY_LEN(a) - 1)
 
 /* changes all forward slashes in token to backslashes */
-void changeForwardSlashesToBackSlashes ( wchar_t *arg )
+void changeForwardSlashesToBackSlashes ( char *arg )
 {
     if ( arg == NULL )
         return;
@@ -54,18 +54,18 @@
     }
 }
 
-int wmain(int argc, wchar_t *argv[ ])
+int main(int argc, char *argv[ ])
 {
     return shellNsinstall ( argv + 1 );
 }
 
 static int
-shellNsinstall (wchar_t **pArgv)
+shellNsinstall (char **pArgv)
 {
     int retVal = 0;     /* exit status */
     int dirOnly = 0;    /* 1 if and only if -D is specified */
-    wchar_t **pSrc;
-    wchar_t **pDst;
+    char **pSrc;
+    char **pDst;
 
     /*
      * Process the command-line options.  We ignore the
@@ -74,7 +74,7 @@
      * argument too.
      */
     while ( *pArgv && **pArgv == '-' ) {
-        wchar_t c = (*pArgv)[1];  /* The char after '-' */
+        char c = (*pArgv)[1];  /* The char after '-' */
 
         if ( c == 'D' ) {
             dirOnly = 1;
@@ -117,14 +117,14 @@
 }
 
 static int
-shellMkdir (wchar_t **pArgv) 
+shellMkdir (char **pArgv) 
 {
     int retVal = 0; /* assume valid return */
-    wchar_t *arg;
-    wchar_t *pArg;
-    wchar_t path[_MAX_PATH];
-    wchar_t tmpPath[_MAX_PATH];
-    wchar_t *pTmpPath = tmpPath;
+    char *arg;
+    char *pArg;
+    char path[_MAX_PATH];
+    char tmpPath[_MAX_PATH];
+    char *pTmpPath = tmpPath;
 
     /* All the options are simply ignored in this implementation */
     while ( *pArgv && **pArgv == '-' ) {
@@ -149,12 +149,12 @@
             *pTmpPath = '\0';
 
             /* check if directory already exists */
-            _wgetcwd ( path, _MAX_PATH );
-            if ( _wchdir ( tmpPath ) != -1 ) {
-                _wchdir ( path );
+            _getcwd ( path, _MAX_PATH );
+            if ( _chdir ( tmpPath ) != -1 ) {
+                _chdir ( path );
             } else {
-                if ( _wmkdir ( tmpPath ) == -1 ) {
-                    printf ( "%ls: ", tmpPath );
+                if ( _mkdir ( tmpPath ) == -1 ) {
+                    printf ( "%s: ", tmpPath );
                     perror ( "Could not create the directory" );
                     retVal = 3;
                     break;
@@ -195,7 +195,7 @@
  */
 
 struct sh_FileData {
-    wchar_t pathName[_MAX_PATH];
+    char pathName[_MAX_PATH];
     DWORD dwFileAttributes;
 };
 
@@ -213,19 +213,19 @@
  */
 
 static BOOL
-sh_RecordFileData(wchar_t *pathName, WIN32_FIND_DATA *findData, void *arg)
+sh_RecordFileData(char *pathName, WIN32_FIND_DATA *findData, void *arg)
 {
     struct sh_FileData *fData = (struct sh_FileData *) arg;
 
-    wcscpy(fData->pathName, pathName);
+    strcpy(fData->pathName, pathName);
     fData->dwFileAttributes = findData->dwFileAttributes;
     return TRUE;
 }
 
 static BOOL
-sh_DoCopy(wchar_t *srcFileName,
+sh_DoCopy(char *srcFileName,
           DWORD srcFileAttributes,
-          wchar_t *dstFileName,
+          char *dstFileName,
           DWORD dstFileAttributes,
           int force,
           int recursive
@@ -239,28 +239,28 @@
     }
 
     if (srcFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
-        fprintf(stderr, "nsinstall: %ls is a directory\n",
+        fprintf(stderr, "nsinstall: %s is a directory\n",
                 srcFileName);
         return FALSE;
     } else {
         DWORD r;
-        wchar_t longSrc[1004] = LONGPATH_PREFIX;
-        wchar_t longDst[1004] = LONGPATH_PREFIX;
+        char longSrc[1004] = LONGPATH_PREFIX;
+        char longDst[1004] = LONGPATH_PREFIX;
         r = GetFullPathName(srcFileName, 1000, longSrc + STR_LEN(LONGPATH_PREFIX), NULL);
         if (!r) {
-            fprintf(stderr, "nsinstall: couldn't get full path of %ls: %s\n",
+            fprintf(stderr, "nsinstall: couldn't get full path of %s: %s\n",
                     srcFileName, sh_GetLastErrorMessage());
             return FALSE;
         }
         r = GetFullPathName(dstFileName, 1000, longDst + ARRAY_LEN(LONGPATH_PREFIX) - 1, NULL);
         if (!r) {
-            fprintf(stderr, "nsinstall: couldn't get full path of %ls: %s\n",
+            fprintf(stderr, "nsinstall: couldn't get full path of %s: %s\n",
                     dstFileName, sh_GetLastErrorMessage());
             return FALSE;
         }
 
         if (!CopyFile(longSrc, longDst, FALSE)) {
-            fprintf(stderr, "nsinstall: cannot copy %ls to %ls: %s\n",
+            fprintf(stderr, "nsinstall: cannot copy %s to %s: %s\n",
                     srcFileName, dstFileName, sh_GetLastErrorMessage());
             return FALSE;
         }
@@ -282,9 +282,9 @@
     int recursive;            /* -r or -R option, recursively copy
                                * directories. Note: this field is not used
                                * by nsinstall and should always be 0. */
-    wchar_t *dstFileName;        /* a buffer for constructing the destination
+    char *dstFileName;        /* a buffer for constructing the destination
                                * file name */
-    wchar_t *dstFileNameMarker;  /* points to where in the dstFileName buffer
+    char *dstFileNameMarker;  /* points to where in the dstFileName buffer
                                * we should write the file component of the
                                * destination file */
 };
@@ -302,23 +302,23 @@
  */
 
 static BOOL
-sh_CpFileCmd(wchar_t *pathName, WIN32_FIND_DATA *findData, void *cpArg)
+sh_CpFileCmd(char *pathName, WIN32_FIND_DATA *findData, void *cpArg)
 {
     BOOL retVal = TRUE;
     struct sh_CpCmdArg *arg = (struct sh_CpCmdArg *) cpArg;
 
-    wcscpy(arg->dstFileNameMarker, findData->cFileName);
+    strcpy(arg->dstFileNameMarker, findData->cFileName);
     return sh_DoCopy(pathName, findData->dwFileAttributes,
             arg->dstFileName, GetFileAttributes(arg->dstFileName),
             arg->force, arg->recursive);
 }
 
 static int
-shellCp (wchar_t **pArgv) 
+shellCp (char **pArgv) 
 {
     int retVal = 0;
-    wchar_t **pSrc;
-    wchar_t **pDst;
+    char **pSrc;
+    char **pDst;
     struct sh_CpCmdArg arg;
     struct sh_FileData dstData;
     int dstIsDir = 0;
@@ -330,7 +330,7 @@
     arg.dstFileNameMarker = 0;
 
     while (*pArgv && **pArgv == '-') {
-        wchar_t *p = *pArgv;
+        char *p = *pArgv;
 
         while (*(++p)) {
             if (*p == 'f') {
@@ -376,7 +376,7 @@
             dstIsDir = 1;
         }
     } else if (n > 1) {
-        fprintf(stderr, "nsinstall: %ls: ambiguous destination file "
+        fprintf(stderr, "nsinstall: %s: ambiguous destination file "
                 "or directory\n", *pDst);
         return 3;
     } else {
@@ -386,11 +386,11 @@
          * name must be fully specified.
          */
 
-        wchar_t *p;
+        char *p;
 
         for (p = *pDst; *p; p++) {
             if (*p == '*' || *p == '?') {
-                fprintf(stderr, "nsinstall: %ls: No such file or directory\n",
+                fprintf(stderr, "nsinstall: %s: No such file or directory\n",
                         *pDst);
                 return 3;
             }
@@ -404,7 +404,7 @@
         if (p > *pDst && p[-1] == '\\' && p != *pDst + 1 && p[-2] != ':') {
             p[-1] = '\0';
         }
-        wcscpy(dstData.pathName, *pDst);
+        strcpy(dstData.pathName, *pDst);
         dstData.dwFileAttributes = 0xFFFFFFFF;
     }
 
@@ -420,7 +420,7 @@
     }
 
     if (dstIsDir) {
-        arg.dstFileNameMarker = arg.dstFileName + wcslen(arg.dstFileName);
+        arg.dstFileNameMarker = arg.dstFileName + strlen(arg.dstFileName);
 
         /*
          * Now arg.dstFileNameMarker is pointing to the null byte at the
@@ -441,7 +441,7 @@
         changeForwardSlashesToBackSlashes(*pSrc);
         sh_EnumerateFiles(*pSrc, *pSrc, sh_RecordFileData, &srcData, &n);
         if (n == 0) {
-            fprintf(stderr, "nsinstall: %ls: No such file or directory\n",
+            fprintf(stderr, "nsinstall: %s: No such file or directory\n",
                     *pSrc);
             retVal = 3;
         } else if (n > 1) {
@@ -468,7 +468,7 @@
             retVal = 3;
         } else {
             if (n == 0) {
-                fprintf(stderr, "nsinstall: %ls: No such file or directory\n",
+                fprintf(stderr, "nsinstall: %s: No such file or directory\n",
                         *pSrc);
                 retVal = 3;
             }
@@ -499,8 +499,8 @@
  */
 
 static BOOL sh_EnumerateFiles(
-        const wchar_t *pattern,
-        const wchar_t *where,
+        const char *pattern,
+        const char *where,
         sh_FileFcn fileFcn,
         void *arg,
         int *nFiles
@@ -508,11 +508,11 @@
 {
     WIN32_FIND_DATA fileData;
     HANDLE hSearch;
-    const wchar_t *src;
-    wchar_t *dst;
-    wchar_t fileName[_MAX_PATH];
-    wchar_t *fileNameMarker = fileName;
-    wchar_t *oldFileNameMarker;
+    const char *src;
+    char *dst;
+    char fileName[_MAX_PATH];
+    char *fileNameMarker = fileName;
+    char *oldFileNameMarker;
     BOOL hasWildcard = FALSE;
     BOOL retVal = TRUE;
     BOOL patternEndsInDotStar = FALSE;
@@ -530,10 +530,10 @@
      * function.  We require that a matched filename have at least
      * the number of dots in the pattern.
      */
-    len = wcslen(pattern);
+    len = strlen(pattern);
     if (len >= 2) {
         /* Start from the end of pattern and go backward */
-        const wchar_t *p = &pattern[len - 1];
+        const char *p = &pattern[len - 1];
 
         /* We can have zero or more *'s */
         while (p >= pattern && *p == '*') {
@@ -613,8 +613,8 @@
          * See if it is the root directory, \, or X:\.
          */
 
-        assert(!wcscmp(fileName, pattern));
-        assert(wcslen(fileName) >= 1);
+        assert(!strcmp(fileName, pattern));
+        assert(strlen(fileName) >= 1);
         if (dst[-1] == '\\' && (dst == fileName + 1 || dst[-2] == ':')) {
             fileData.cFileName[0] = '\0';
         } else {
@@ -627,7 +627,7 @@
                 dst[-1] = '\0';
                 fileNameMarker = oldFileNameMarker;
             } 
-            wcscpy(fileData.cFileName, fileNameMarker);
+            strcpy(fileData.cFileName, fileNameMarker);
         }
         fileData.dwFileAttributes = GetFileAttributes(fileName);
         if (fileData.dwFileAttributes == 0xFFFFFFFF) {
@@ -643,8 +643,8 @@
     }
 
     do {
-        if (!wcscmp(fileData.cFileName, L".")
-                || !wcscmp(fileData.cFileName, L"..")) {
+        if (!strcmp(fileData.cFileName, ".")
+                || !strcmp(fileData.cFileName, "..")) {
             /* 
              * Skip over . and ..
              */
@@ -654,7 +654,7 @@
 
         if (patternEndsInDotStar) {
             int nDots = 0;
-            wchar_t *p = fileData.cFileName;
+            char *p = fileData.cFileName;
             while (*p) {
                 if (*p == '.') {
                     nDots++;
@@ -680,7 +680,7 @@
             }
         }
 
-        wcscpy(fileNameMarker, fileData.cFileName);
+        strcpy(fileNameMarker, fileData.cFileName);
         if (*src && *(src + 1)) {
             /*
              * More to go.  Recurse.
@@ -689,13 +689,13 @@
             int n;
 
             assert(*src == '\\');
-            where = fileName + wcslen(fileName);
-            wcscat(fileName, src);
+            where = fileName + strlen(fileName);
+            strcat(fileName, src);
             sh_EnumerateFiles(fileName, where, fileFcn, arg, &n);
             *nFiles += n;
         } else {
-            assert(wcschr(fileName, '*') == NULL);
-            assert(wcschr(fileName, '?') == NULL);
+            assert(strchr(fileName, '*') == NULL);
+            assert(strchr(fileName, '?') == NULL);
             (*nFiles)++;
             if ((*fileFcn)(fileName, &fileData, arg) == FALSE) {
                 retVal = FALSE;
--- a/toolkit/toolkit-makefiles.sh
+++ b/toolkit/toolkit-makefiles.sh
@@ -138,6 +138,10 @@
   parser/htmlparser/tests/outsinks/Makefile
 "
 
+MAKEFILES_html5="
+  parser/html/Makefile
+"
+
 MAKEFILES_intl="
   intl/Makefile
   intl/build/Makefile
@@ -881,6 +885,7 @@
   $MAKEFILES_xmlparser
   $MAKEFILES_gfx
   $MAKEFILES_htmlparser
+  $MAKEFILES_html5
   $MAKEFILES_intl
   $MAKEFILES_liveconnect
   $MAKEFILES_xpconnect
--- a/gfx/thebes/Makefile.in
+++ b/gfx/thebes/Makefile.in
@@ -8,7 +8,11 @@
 
 MODULE	= thebes
 
-DIRS	= public src mochitest
+DIRS	= public src
+
+ifdef ENABLE_TESTS
+DIRS	+= mochitest
+endif
 
 ifdef ENABLE_TESTS
 ifndef MOZ_ENABLE_LIBXUL
--- a/build/autoconf/make-makefile
+++ b/build/autoconf/make-makefile
@@ -45,7 +45,7 @@
 #$debug = 1;
 
 if ($^O eq 'msys') {
-  $pwdcmd = 'pwd -W';
+  $pwdcmd = 'sh -c pwd -W';
 }
 else {
   $pwdcmd = 'pwd';
--- a/media/libtheora/lib/Makefile.in
+++ b/media/libtheora/lib/Makefile.in
@@ -77,26 +77,24 @@
 ifeq ($(findstring 86,$(OS_TEST)), 86)
 ifeq ($(OS_ARCH),WINNT)
 ifneq (64,$(findstring 64,$(OS_TEST)))
+ifndef GNU_CC
 VPATH		+= $(srcdir)/x86_vc
+else
+VPATH		+= $(srcdir)/x86
 
-CSRCS		+= \
-		mmxidct.c \
-		mmxfrag.c \
-		mmxstate.c \
-		x86state.c \
-		$(NULL)
+endif
 endif
 else
 VPATH		+= $(srcdir)/x86
 
+endif
 CSRCS		+= \
 		mmxidct.c \
 		mmxfrag.c \
 		mmxstate.c \
 		x86state.c \
 		$(NULL)
 endif
-endif
 
 include $(topsrcdir)/config/rules.mk
